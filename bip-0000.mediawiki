<pre>
  BIP: ????
  Layer: Applications
  Title: Silent Payments
  Author: josibake <josibake@protonmail.com>
          Ruben Somsen <rsomsen@gmail.com>
  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????
  Status: Draft
  Type: Informational
  Created: 2023-03-09
  License: MIT
</pre>

== Introduction ==

=== Abstract ===

=== Copyright ===

=== Motivation ===

Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.

However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name="out_of_band_notifications">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.

This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy.

This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[bip-0000.mediawiki#appendix-b-light-client-support|Appendix: Light Client Support]]).

== Goals ==

We aim to present a transaction protocol which satisifies the following properties:

* No increase in the size or cost of transactions
* Resulting transactions blend in with other bitcoin transactions and can’t be distinguished
* Transactions can’t be linked to a silent payment address by an outside observer
* No sender-receiver interaction required
* No linking of multiple payments to the same sender
* Each silent payment goes to a unique address, avoiding accidental address reuse
* Supports payment labeling
* Uses existing seed phrase or descriptor methods for backup and recovery
* Separates scanning and spending responsibilities
* Compatible with other spending protocols, such as CoinJoin
* Light client/SPV wallet support
* Protocol is upgradeable

== Overview ==

We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and G represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[bip-0000.mediawiki#specification|Specification]].

''' Simple case '''

Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:

* Let ''P = hash(a·B)·G + B''
* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output

Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = hash(b·A)·G + B'' and seeing that ''P'' is present in the transaction outputs).

''' Creating more than one output '''

In order to allow Alice to create more than one output for Bob<ref name="why_more_than_one_output">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, such as making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:

* Let ''n = 0''
* Let ''P<sub>0</sub> = hash(a·B || n)·G + B''
* For additional outputs:
** Increment ''n'' by one (''n++'')
** Let ''P<sub>i</sub> = hash(a·B || n)·G + B''

Bob detects this output the same as before by searching for ''P<sub>0</sub> = hash(b·A || 0)·G + B''. Once he detects the first output, he must:

* Check for ''P<sub>1</sub> = hash(b·A || 1)·G + B''
* If ''P<sub>1</sub>'' is not found, stop
* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found

Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.

''' Preventing address reuse '''

If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:

* Let ''outpoint_hash = hash(txid || vout)''
* Let ''P<sub>0</sub> = hash(outpoint_hash·a·B || 0)·G + B''

Bob must include the same ''outpoint_hash'' when scanning.

''' Using all inputs '''

In our simplified example we have been referring to Alice’s transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name="other_inputs">'''What about inputs without public keys?''' Inputs without public keys (such as ''P2SH'' outputs) can still be spent in the transaction but are not included in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name="using_all_inputs">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 32 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=""all_inputs_and_coinjoin">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying</ref>.

Alice performs the tweak with the sum of her input private keys in the following manner:

* Let ''outpoints_hash = hash(txid<sub>1</sub> || vout<sub>1</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''
* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''
* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B || 0)·G + B''

''' Spend and Scan Key '''

Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob’s public keys in the following manner:

* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G + B<sub>spend</sub>''

Bob detects this payment by calculating ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A)·G + B<sub>spend</sub>'' with his online device and can spend from his cold storage signing device using ''(hash(outpoints_hash·b<sub>scan</sub>·A) + b<sub>spend</sub>) mod p'' as the private key.

''' Labels '''

For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments by using labels. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can tweak his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:

* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''
* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''

Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:

* Let ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G + B<sub>spend</sub>''
* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used

It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.

''' Labels for change '''

Bob can also use labels for managing his own change outputs. To do so, he can reserve a special label in the following manner:

* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G

Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:

* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction
* Let ''P<sub>change</sub> = hash(outpoints_hash·a·B<sub>change</sub> || 0)·G + B<sub>spend</sub>''

This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key.

== Specification ==

We use the following functions and conventions:

* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer i as a 4-byte sequence, least significant byte first

For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].

=== Versions ===

This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as Segwit addresses. Future upgrades to silent payments will require a new version. For ''Silent Payments v0'':

* Recipient addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name="why_taproot">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity.</ref>
* The sender must sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is not supported). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name="why_sighash_all">'''Why only ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[bip-0000.mediawiki#specification|Allowed Inputs]]'' public keys, the inputs and outputs must not change once the sender has signed the transaction. If the inputs or outputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>
* Inputs used to derive the shared secret are from the ''[[bip-0000.mediawiki#specification|Allowed Inputs]]'' list

A transaction is not a ''Silent Payments v0'' transaction and should be skipped entirely<ref name="why_skip_transactions">'''Why skip transactions with unknown script fragments?''' Skipping transactions with unknown elements allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules.</ref> when scanning if any of the following are true:

* The transaction does not contain any BIP341 taproot outputs
* The transaction does not have at least one input from the ''Allowed Inputs'' list
* The transaction inputs contain a new, undefined output type

=== Address encoding ===

A silent payment address is constructed in the following manner:

* Let ''B<sub>scan</sub>, b<sub>scan</sub> = Recipient’s [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] scan public key and corresponding private key''
* Let ''B<sub>spend</sub>, b<sub>spend</sub> = Recipient’s [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] spend public key and corresponding private key''
* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G'', where ''m'' an optional integer tweak for labeling
** In the case of ''m'' = 0, no label is applied and ''B<sub>m</sub> = B<sub>spend</sub>''
* The final address is a [https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki Bech32m] encoding of:
** The human-readable part "sp" for mainnet, "tsp" for testnet and signet, and "sprt" for regtest
** The data-part values:
*** The character "q", to represent a silent payment address of version 0
*** The 64 byte concatenation of the Recipient's public keys, ''B<sub>m</sub> || B<sub>scan</sub>''

=== Outpoint hash ===

The sender and receiver MUST calculate an outpoint hash for the transaction in the following manner:

* Collect each ''outpoint(36)'' used as an input to the transaction
* Sort the ''outpoints'' by txid and vout, in ascending order
* Let ''outpoints = txid<sub>0</sub> || ser<sub>32</sub>(vout<sub>0</sub>) || … || txid<sub>n</sub> || ser<sub>32</sub>(vout<sub>n</sub>)''
* Let ''outpoint_hash = sha256(outpoints), truncated to the first 16 bytes''<ref name="why_16byte_hash">'''How was a 16 byte hash chosen?''' In order to support light clients, we expect a full node to calculate ''outpoint_hash·A'', where ''A'' is the sum of the input public keys for a transaction. Using a 16 byte hash instead of a 32 byte will speed up the EC multiplication by ~2x, assuming an optimized implementation. This is in keeping with a server-client model, where we want to minimize the work done by the server. Conversely, we don't want the hash to be too small as this increases the risk of a collision when spending UTXOs from the same public key. Using a 16 byte hash means we can spend from the same public key 6.1×10<sup>6</sup> times with only a ''p = 10<sup>−6</sup>'' probability of a collision (see [https://en.wikipedia.org/wiki/Birthday_problem#Probability_table Birthday Problem] for more details)</ref>

=== Allowed Inputs ===

While any UTXO can be used to fund the transaction, the sender and receiver MUST use inputs from the following list when deriving the shared secret:

* ''P2TR (keypath spends)''
* ''P2WPKH''
* ''P2SH-P2WPKH''
* ''P2PKH''

''' P2TR (keypath spends)'''

The sender MUST use the tweaked private key corresponding to the taproot outer key (e.g. the tweaked private key for a keypath spend). If the sender cannot use the keypath spend or intends to spend the UTXO as a script path spend, they MUST NOT include the UTXO when funding a silent payment transaction.

The receiver always uses the outer public key when scanning regardless of whether the taproot output is a keypath spend or a scriptpath spend, unless the outer public key is a NUMS point. If the outer public key is a NUMS point, the receiver MUST skip the input when deriving the shared secret. This is to address a CoinJoin malleability issue<ref name="why_always_outer_pubkey">''' Why not always skip Taproot script path spends? ''' If the silent payments protocol skipped taproot script path spends, this would allow an attacker to join a CoinJoin round, participate in deriving the silent payment address using the tweaked private key for a keypath spend, and then broadcast their own version of the transaction using the script path spend. If receiver were to only consider keypath spends, they would skip the attacker's script path spend input when deriving the shared secret and not be able to find the funds.</ref>

''' P2WPKH '''

The sender performs the tweak using the private key for the output and the receiver obtains the public key from the ''witness''.

''' P2SH-P2WPKH '''

The sender performs the tweak using the private key for the nested ''P2WPKH'' output and the receiver obtains the public key from the ''redeemScript''.

''' P2PKH '''

The sender performs the tweak using the private key for the output and MUST sign using the standard script template:


    scriptSig: <Signature> <Public Key>


The receiver obtains the public key from the ''scriptSig''. The receiver MUST parse the ''scriptSig'' for the public key, even if the ''scriptSig'' is non-standard (e.g. <code><dummy> OP_DROP <Signature> <Public Key></code>). This is to address the [[third-party malleability of ''P2PKH'' ''scriptSigs'']](https://en.bitcoin.it/wiki/Transaction_malleability).

See [[bip-0000.mediawiki#appendix-b-allowed-inputs|Appendix B: Allowed Inputs]] for an explanation on why other output types are not included.

=== Sender ===

==== Selecting inputs ====

The sending wallet performs coin selection as usual with the following restrictions:

* At least one input MUST be from the ''Allowed Inputs'' list
* Exclude ''P2TR'' scriptpath spends

==== Creating outputs ====

After the inputs have been selected, the sender can create one or more outputs for one or more silent payment addresses in the following manner:

* Let ''a = a<sub>0</sub> + a<sub>1</sub> + … a<sub>i</sub>'', where each ''a<sub>i</sub>'' is the 256-bit private key(s) of an input from the ''Allowed Inputs'' list
* Let ''ecdh_shared_secret = outpoint_hash·a·B<sub>scan</sub>''
* Group receiver silent payment addresses by ''B<sub>scan</sub>'' (e.g. each group consists of one ''B<sub>scan</sub>'' and one or more ''B<sub>m</sub>'')
* For each group:
** Let ''n = 0''
** For each ''B<sub>m</sub>'' in the group:
*** Let ''t<sub>n</sub> = sha256(ecdh_shared_secret) || ser<sub>32</sub>(n))''
*** Let ''P<sub>mn</sub> = t<sub>n</sub>·G + B<sub>m</sub>''
*** Encode ''P<sub>mn</sub>'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output
*** Optionally, repeat with n++ to create additional outputs for the current ''B<sub>m</sub>''
*** If no additional outputs are required, continue to the next ''B<sub>m</sub>'' with ''n++''

The sender should check to ensure that no two outputs in the final transaction have the same ''t<sub>n</sub>'' as this could result in a loss of privacy for the receiver<ref name="why_not_the_same_tn">''' Why can't two outputs have the same ''t<sub>n</sub>''?''' If paying the same entity but to two separate labeled addresses in the same transaction without incrementing ''n'', the two outputs would be ''t<sub>n</sub>·G + B<sub>spend</sub> + i·G'' and ''t<sub>n</sub>·G + B<sub>spend</sub> + j·G''. The attacker could brute force by subtracting different values for ''i·G'' and ''j·G'' until they find that both outputs have ''t<sub>n</sub>·G + B<sub>spend</sub>'' in common. This would allow them to deduce that this transaction is a silent payment transaction and that a single entity received two outputs, paid to two separate silent payment addresses. This does not allow the attacker to determine either of the silent payment addresses</ref>.

=== Receiver ===

==== Key Derivation ====

Two keys are needed to create a silent payments address: the spend key and the scan key. While these keys can be generated independently, wallet software SHOULD use BIP32 derivation<ref name="bip32_derivation">'''Why use BIP32 hardened derivation?''' Using BIP32 derivation allows users to add silent payments to an existing master seed. It also ensures that a user’s silent payment funds are recoverable in any wallet which supports BIP32 derivation. Using hardened derivation ensures that it is safe to export the scan private key without exposing the master key or spend private key</ref> to ensure compatibility across wallets.

A scan and spend key pair using BIP32 derivation are defined (taking inspiration from [https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki BIP44]) in the following manner:


    Spend private key: m / purpose' / coin_type' / account' / silent_payment_version' / 0' / k
     Scan private key: m / purpose' / coin_type' / account' / silent_payment_version' / 1'/ k

Each value of ''k'' represents a pair of private keys needed for creating a silent payment address. In this way, multiple silent payment addresses can be derived from a single master key. Wallet software MUST use hardened derivation to ensure the master key is not exposed in the event the scan private key is compromised. Purpose is a constant set to ''BIP_NUMBER'' (or ''BIP_NUMBER_HEX'') following the BIP43 recommendation. Refer to [https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki BIP44] for more details.

==== Scanning ====

For each transaction the receiving wallet suspects might be a silent payment to themselves, it must<ref name="data_needed_for_scanning>'''What data does a wallet need for scanning''' A wallet needs a 32 byte public key which represents the sum of the input public keys of a transaction, the truncated 16 byte hash of the transaction input outpoints, and some method of determining whether or not a scriptPubKey exists in a block. For full nodes, all of this data is already available. For light clients, they would need to request the tweak data from a server with access to the necessary information for tweaking and determine existence in a block using something like BIP158. BIP158 is recommended over other methods as this is the most trust minimized, privacy preserving method for light clients today.</ref>:

* Generate the ''outpoint_hash'', using the method described above
* Let ''A = A<sub>0</sub> + A<sub>1</sub> + … A<sub>i</sub>'', where each ''A<sub>i</sub>'' is the public key(s) of an input from the ''Allowed Inputs'' list
* Let ''ecdh_shared_secret = outpoint_hash·b<sub>scan</sub>·A''
* Check for outputs:
** Let ''outputs_to_check = all unspent taproot outputs in the transaction''
** Starting with ''n = 0'':
*** Let ''t<sub>n</sub> = sha256(ecdh_shared_secret || n)''
*** Compute ''P<sub>n</sub> = t<sub>n</sub>·G + B<sub>spend</sub>''
**** If ''P<sub>n</sub>'' is in ''outputs_to_check'', add it to the wallet and continue with ''n++''
**** If ''P<sub>n</sub>'' is not found and the wallet has precomputed labels<ref name="precompute_labels">''' Why precompute labels?''' Naively, a wallet could some max integer ''M'' which indicates the total number of labels it has used. When checking a transaction, the wallet would need to add all possible labels to each output. This ends up being ''n·m'' additions, where ''n'' is the number of outputs in the transaction and ''m'' is the number of labels in the wallet</ref>:
***** For each output in ''outputs_to_check'', check if ''output - P<sub>n</sub>'' exists in the list of labels used by the wallet
***** If a match is found, add the output (''P<sub>n</sub> + m·G'') to the wallet and continue with ''n++''
**** If no matches are found, stop

==== Backup and Recovery ====

Since each silent payment output address is derived independently, descriptor wallets are recommended along with regular backups. When recovering from a backup, the wallet will need to scan since the last backup to detect new payments.

If using a seed phrase only style backup, the user can recover the wallet’s unspent outputs from the UTXO set (by only scanning transactions with at least one unspent taproot output) and can recover the full wallet history by scanning the blockchain, starting from the wallet birthday. If a wallet uses labels, this information SHOULD be included in the backup. If the user does not know whether or not labels were used, they can precompute a large number of labels based on a safe upper bound (e.g 100k labels) to use when re-scanning.

== Appendix A: Allowed Inputs ==

TBD

== Appendix B: Light Client Support ==

TBD

== Test Vectors ==

TBD

== Rationale and References ==
<references/>

== Acknowledgements ==

TBD
